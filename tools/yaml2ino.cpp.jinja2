{# Little Less Protocol Suite - yaml converter
   Copyright (C) 2020 Frank Mueller

   SPDX-License-Identifier: MIT

   This is a template to generate ino files for Arduino.
#}
#include <LittleLessProtocol.h>

class {{ yaml['shortName'] | identifier }}Protocol{{ suffix }} : public {{ yaml['baseProtocol'].value }}{{ suffix }} {
public:
  struct cmd {
    enum : uint8_t  {
    {% for cmd in yaml['commands'] %}
      {{+ cmd['longName'] | identifier }} = {{ cmd['id'].value }}{% if not loop.last %},{% endif %}

    {% endfor %}
    };
  };

  {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}(Stream &stream)
    : LittleLessBaseA(stream, {{ "0x%x%x" | format(yaml['maxVersion'].value, yaml['minVersion'].value) }})
  {}

{% if yaml['baseProtocol'].value == 'LittleLessBase' %}
  virtual void getAppName(uint8_t &len, const char **name);
  virtual void getAppExtra(uint8_t &len, const char **extra);
  virtual void handleConStateChanged(bool conState);

{% endif %}
  virtual uint8_t getCmdId(const char cmd[3]);
  virtual bool getCmdStr(uint8_t cmdId, char cmd[3]);
  virtual bool canHandleMsg(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx);
  virtual void handleMsgData(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx);
  virtual void handleMsgFinish(llp_MsgType msgType, uint8_t cmdId, bool msgOK);

{% for cmd in yaml['commands'] %}
  inline bool canHandle{{ cmd['longName'] | identifier }}(llp_MsgType msgType, llp_RxStruct &rx);
  inline void handle{{ cmd['longName'] | identifier }}Data(llp_MsgType msgType, llp_RxStruct &rx);
  inline void handle{{ cmd['longName'] | identifier }}Finish(llp_MsgType msgType, bool msgOK);
{% endfor %}

private:
  static const char PROTO_NAME[];
  static const char PROTO_EXTRA[];
  static const char * const S_CMDS[];
};

{{ yaml['shortName'] | identifier }}Protocol{{ suffix }} {{ yaml['shortName'] | identifier(true) }}(Serial);

void setup() {
  Serial.begin(9600);
}

void loop() {
  {{ yaml['shortName'] | identifier(true) }}.loop();
}

{% if yaml['baseProtocol'].value == 'LittleLessBase' %}

//////////////////////////////////////////////////
// LittleLessBase handling
//////////////////////////////////////////////////

const char {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::PROTO_NAME[]  PROGMEM = "{{ yaml['shortName'].text }}";
const char {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::PROTO_EXTRA[] PROGMEM = "{{ participant }}";  // ToDo

{% for cmd in yaml['commands'] %}
static const char CMD_{{ cmd['longName'] | upper_identifier }}[3] PROGMEM = "{{ cmd['shortName'].text }}";
{% endfor %}

const char * const {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::S_CMDS[{{ yaml['commands'] | length }}] PROGMEM = {
  {%+ for cmd in yaml['commands'] %}CMD_{{ cmd['longName'] | upper_identifier }}{% if not loop.last %}, {% endif %}{% endfor %}

};

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::getAppName(uint8_t &len, const char **name) {
  len = strlen_P(PROTO_NAME);
  *name = PROTO_NAME; 
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::getAppExtra(uint8_t &len, const char **extra) {
  len = strlen_P(PROTO_EXTRA);
  *extra = PROTO_EXTRA;
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::handleConStateChanged(bool conState) {
  // ToDo
  // if (conState) {
  //   ..
  // } else {
  //   ..
  // }
}

{% endif %}

//////////////////////////////////////////////////
// Command ID handling
//////////////////////////////////////////////////

uint8_t {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::getCmdId(const char cmd[3]) {
  for (uint8_t i = 0; i < sizeof(S_CMDS)/sizeof(S_CMDS[0]); ++i) {
    char *str = pgm_read_ptr(S_CMDS + i);
    if (0 == memcmp_P(cmd, str, 3)) {
      return {{ yaml['commands'][0]['id'].value }} + i;  {# ToDo check if command ids are in sequence and without a gap! #}

    }
  }
  return {{ yaml['baseProtocol'].value }}{{ suffix }}::getCmdId(cmd);
}

bool {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::getCmdStr(uint8_t cmdId, char cmd[3]) {
  if (   (cmdId >= {{ yaml['commands'][0]['id'].value }})
      && ((cmdId - {{ yaml['commands'][0]['id'].value }}) < sizeof(S_CMDS)/sizeof(S_CMDS[0]))) {
    char *str = pgm_read_ptr(S_CMDS + cmdId - {{ yaml['commands'][0]['id'].value }});  {# ToDo check if command ids are in sequence and without a gap! #}

    memcpy_P(cmd, str, 3);
    return true;
  } else {
    return {{ yaml['baseProtocol'].value }}{{ suffix }}::getCmdStr(cmdId, cmd);
  }
}


//////////////////////////////////////////////////
// general rx handling
//////////////////////////////////////////////////

bool {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::canHandleMsg(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['longName'] | identifier }}: canHandle{{ cmd['longName'] | identifier }}(msgType, rx); break;
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      {{ yaml['baseProtocol'].value }}{{ suffix }}::canHandleMsg(msgType, cmdId, rx);
    {% endif %}
      break;
  }
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::handleMsgData(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['longName'] | identifier }}: handle{{ cmd['longName'] | identifier }}Data(msgType, rx); break;
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      {{ yaml['baseProtocol'].value }}{{ suffix }}::handleMsgData(msgType, cmdId, rx);
    {% endif %}
      break;
  }
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::handleMsgFinish(llp_MsgType msgType, uint8_t cmdId, bool msgOK) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['longName'] | identifier }}: handle{{ cmd['longName'] | identifier }}Finish(msgType, msgOK); break;
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      {{ yaml['baseProtocol'].value }}{{ suffix }}::handleMsgFinish(msgType, cmdId, msgOK);
    {% endif %}
      break;
  }
}

{% for cmd in yaml['commands'] %}

//////////////////////////////////////////////////
// {{ cmd | cmd_title }}
{{ cmd['description'].text | comment }}
{% for structure in cmd['structures'] %}
/////////////////////////
  {% if 'messageTypes' in structure %}
// Message types: {% for types in structure['messageTypes'] %}{{ types.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
  {% if 'senders' in structure %}
// Senders: {% for sender in structure['senders'] %}{{ sender.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
  {% if 'receivers' in structure %}
// Receivers: {% for receiver in structure['receivers'] %}{{ receiver.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
//
{{ structure['description'].text | comment }}
//
  {% if structure['structureType'].text == 'markdown' -%}
    {{     structure['structureDesc'].text | comment }}
  {% endif -%}
{% endfor -%}
//////////////////////////////////////////////////

bool {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::canHandle{{ cmd['longName'] | identifier }}(llp_MsgType msgType, llp_RxStruct &rx) {
  // ToDo
  // rx.buf = buffer;
  // rx.bufTotalSize = sizeof(buffer); 
  // return true;
  return false;
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::handle{{ cmd['longName'] | identifier }}Data(llp_MsgType msgType, llp_RxStruct &rx) {
  // ToDo
  // on error set rx.buf = NULL; to call handle{{ cmd['longName'] | identifier }}Finish(false)
}

void {{ yaml['shortName'] | identifier }}Protocol{{ suffix }}::handle{{ cmd['longName'] | identifier }}Finish(llp_MsgType msgType, bool msgOK) {
  // ToDo
  // if (msgOK) {
  //   ..
  // } else {
  //   .. 
  // }
}

{% endfor %}
