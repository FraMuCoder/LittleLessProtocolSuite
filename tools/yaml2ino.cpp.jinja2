{# Little Less Protocol Suite - yaml converter
   Copyright (C) 2020 Frank Mueller

   SPDX-License-Identifier: MIT

   This is a template to generate ino files for Arduino.
#}
{% macro class() %}
{{ yaml['name'] | identifier -}}
{% if not yaml['name'].text.lower().endswith('protocol') %}Protocol{% endif %}
{{ suffix -}}
{% endmacro %}
{% macro instance() %}
{{ yaml['name'] | identifier(true) -}}
{% if not yaml['name'].text.lower().endswith('protocol') %}Protocol{% endif %}
{% endmacro %}
{% macro baseClass() %}
  {% if baseProtocol in yaml %}
{{ yaml['baseProtocol'].value }}{{ suffix -}}
  {% else %}
LittleLessProtocol{{ suffix -}}
  {% endif %}
{% endmacro %}
#include <LittleLessProtocol.h>

class {{ class() }} : public {{ baseClass() }} {
public:
  struct cmd {
    enum : uint8_t  {
    {% for cmd in yaml['commands'] %}
      {{+ cmd['name'] | identifier }} = {{ cmd['id'].value }}{% if not loop.last %},{% endif %}

    {% endfor %}
    };
  };

  {{ class() }}(Stream &stream)
{% if ('baseProtocol' in ymal) and (yaml['baseProtocol'].value == 'LittleLessBase') %}
    : {{ baseClass() }}(stream, {{ "0x%x%x" | format(yaml['maxVersion'].value, yaml['minVersion'].value) }})
{% else %}
    : {{ baseClass() }}(stream)
{% endif %}
  {}

{% if ('baseProtocol' in ymal) and (yaml['baseProtocol'].value == 'LittleLessBase') %}
  virtual void getAppName(uint8_t &len, const char **name);
  virtual void getAppExtra(uint8_t &len, const char **extra);
  virtual void handleConStateChanged(bool conState);

{% endif %}
  virtual uint8_t getCmdId(const char cmd[3]);
  virtual bool getCmdStr(uint8_t cmdId, char cmd[3]);
  virtual bool canHandleMsg(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx);
  virtual void handleMsgData(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx);
  virtual void handleMsgFinish(llp_MsgType msgType, uint8_t cmdId, bool msgOK);

{% for cmd in yaml['commands'] %}
  inline bool canHandle{{ cmd['name'] | identifier }}(llp_MsgType msgType, llp_RxStruct &rx);
  inline void handle{{ cmd['name'] | identifier }}Data(llp_MsgType msgType, llp_RxStruct &rx);
  inline void handle{{ cmd['name'] | identifier }}Finish(llp_MsgType msgType, bool msgOK);
{% endfor %}

private:
  static const char PROTO_NAME[];
  static const char PROTO_EXTRA[];
  static const char * const S_CMDS[];
};

{{ class() }} {{ instance() }}(Serial);

void setup() {
  Serial.begin(9600);
}

void loop() {
  {{ instance() }}.loop();
}

{% if ('baseProtocol' in ymal) and (yaml['baseProtocol'].value == 'LittleLessBase') %}

//////////////////////////////////////////////////
// LittleLessBase handling
//////////////////////////////////////////////////

const char {{ class() }}::PROTO_NAME[]  PROGMEM = "{{ yaml['code'].text }}";
const char {{ class() }}::PROTO_EXTRA[] PROGMEM = "{{ participant }}";  // ToDo

{% for cmd in yaml['commands'] %}
static const char CMD_{{ cmd['name'] | upper_identifier }}[3] PROGMEM = "{{ cmd['code'].text }}";
{% endfor %}

const char * const {{ class() }}::S_CMDS[{{ yaml['commands'] | length }}] PROGMEM = {
  {%+ for cmd in yaml['commands'] %}CMD_{{ cmd['name'] | upper_identifier }}{% if not loop.last %}, {% endif %}{% endfor %}

};

void {{ class() }}::getAppName(uint8_t &len, const char **name) {
  len = strlen_P(PROTO_NAME);
  *name = PROTO_NAME; 
}

void {{ class() }}::getAppExtra(uint8_t &len, const char **extra) {
  len = strlen_P(PROTO_EXTRA);
  *extra = PROTO_EXTRA;
}

void {{ class() }}::handleConStateChanged(bool conState) {
  // ToDo
  // if (conState) {
  //   ..
  // } else {
  //   ..
  // }
}

{% endif %}

//////////////////////////////////////////////////
// Command ID handling
//////////////////////////////////////////////////

uint8_t {{ class() }}::getCmdId(const char cmd[3]) {
  for (uint8_t i = 0; i < sizeof(S_CMDS)/sizeof(S_CMDS[0]); ++i) {
    char *str = pgm_read_ptr(S_CMDS + i);
    if (0 == memcmp_P(cmd, str, 3)) {
      return {{ yaml['commands'][0]['id'].value }} + i;  {# ToDo check if command ids are in sequence and without a gap! #}

    }
  }
  return {{ baseClass() }}::getCmdId(cmd);
}

bool {{ class() }}::getCmdStr(uint8_t cmdId, char cmd[3]) {
  if (   (cmdId >= {{ yaml['commands'][0]['id'].value }})
      && ((cmdId - {{ yaml['commands'][0]['id'].value }}) < sizeof(S_CMDS)/sizeof(S_CMDS[0]))) {
    char *str = pgm_read_ptr(S_CMDS + cmdId - {{ yaml['commands'][0]['id'].value }});  {# ToDo check if command ids are in sequence and without a gap! #}

    memcpy_P(cmd, str, 3);
    return true;
  } else {
    return {{ baseClass() }}::getCmdStr(cmdId, cmd);
  }
}


//////////////////////////////////////////////////
// general rx handling
//////////////////////////////////////////////////

bool {{ class() }}::canHandleMsg(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['name'] | identifier }}: return canHandle{{ cmd['name'] | identifier }}(msgType, rx);
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      return {{ baseClass() }}::canHandleMsg(msgType, cmdId, rx);
    {% endif %}
  }
}

void {{ class() }}::handleMsgData(llp_MsgType msgType, uint8_t cmdId, llp_RxStruct &rx) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['name'] | identifier }}: handle{{ cmd['name'] | identifier }}Data(msgType, rx); break;
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      {{ baseClass() }}::handleMsgData(msgType, cmdId, rx);
    {% endif %}
      break;
  }
}

void {{ class() }}::handleMsgFinish(llp_MsgType msgType, uint8_t cmdId, bool msgOK) {
  switch (cmdId) {
  {% for cmd in yaml['commands'] %}
    case cmd::{{ cmd['name'] | identifier }}: handle{{ cmd['name'] | identifier }}Finish(msgType, msgOK); break;
  {% endfor %}
    default:
    {% if ('baseProtocol' in yaml) and (yaml['baseProtocol'].value != 'LittleLessProtocol') %}
      {{ baseClass() }}::handleMsgFinish(msgType, cmdId, msgOK);
    {% endif %}
      break;
  }
}

{% for cmd in yaml['commands'] %}

//////////////////////////////////////////////////
// {{ cmd | cmd_title }}
{% if 'description' in cmd %}
{{ cmd['description'].text | comment }}
{% endif %}
{% for message in cmd['messages'] %}
/////////////////////////
  {% if 'messageTypes' in message %}
// Message types: {% for types in message['messageTypes'] %}{{ types.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
  {% if 'senders' in message %}
// Senders: {% for sender in message['senders'] %}{{ sender.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
  {% if 'receivers' in message %}
// Receivers: {% for receiver in message['receivers'] %}{{ receiver.text }}{% if not loop.last %}, {% endif %}{% endfor %}

  {% endif %}
//
  {% if 'description' in message %}
{{ message['description'].text | comment }}
  {% endif %}
//
  {% if message['structureType'].text == 'markdown' %}
{{     message['structureDesc'].text | comment }}
  {% endif %}
{% endfor %}
//////////////////////////////////////////////////

bool {{ class() }}::canHandle{{ cmd['name'] | identifier }}(llp_MsgType msgType, llp_RxStruct &rx) {
  // ToDo
  // rx.buf = buffer;
  // rx.bufTotalSize = sizeof(buffer); 
  // return true;
  return false;
}

void {{ class() }}::handle{{ cmd['name'] | identifier }}Data(llp_MsgType msgType, llp_RxStruct &rx) {
  // ToDo
  // on error set rx.buf = NULL; to call handle{{ cmd['name'] | identifier }}Finish(false)
}

void {{ class() }}::handle{{ cmd['name'] | identifier }}Finish(llp_MsgType msgType, bool msgOK) {
  // ToDo
  // if (msgOK) {
  //   ..
  // } else {
  //   .. 
  // }
}

{% endfor %}
